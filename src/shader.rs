// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.15.2
// Changes made to this file will not be saved.
// SourceHash: ce6d677e0fc4723725c2ba271ea8bf24245acde0ddea8b87fa2cafd4aaf6544c

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Shader,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::Shader => shader::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(
        &self,
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        match self {
            Self::Shader => shader::create_shader_module_embed_source(device),
        }
    }
}
mod _root {
    pub use super::*;
}
pub mod shader {
    use super::{_root, _root::*};
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy, encase::ShaderType)]
    pub struct AppState {
        pub position: glam::Vec2,
        pub zoom: f32,
        pub drag: f32,
        pub delta_t: f32,
        pub num_gravitons: u32,
    }
    impl AppState {
        pub const fn new(
            position: glam::Vec2,
            zoom: f32,
            drag: f32,
            delta_t: f32,
            num_gravitons: u32,
        ) -> Self {
            Self {
                position,
                zoom,
                drag,
                delta_t,
                num_gravitons,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy, encase::ShaderType)]
    pub struct Graviton {
        pub position: glam::Vec2,
        pub color: glam::Vec4,
    }
    impl Graviton {
        pub const fn new(position: glam::Vec2, color: glam::Vec4) -> Self {
            Self { position, color }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy, encase::ShaderType)]
    pub struct VertexInput {
        pub vertex_index: [u8; 0x4],
    }
    impl VertexInput {
        pub const fn new() -> Self {
            Self { vertex_index: [0; 0x4] }
        }
    }
    impl VertexInput {
        pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 0] = [];
        pub const fn vertex_buffer_layout(
            step_mode: wgpu::VertexStepMode,
        ) -> wgpu::VertexBufferLayout<'static> {
            wgpu::VertexBufferLayout {
                array_stride: std::mem::size_of::<Self>() as u64,
                step_mode,
                attributes: &Self::VERTEX_ATTRIBUTES,
            }
        }
    }
    pub const MAX_GRAVITONS: u32 = 256u32;
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub app_state: wgpu::BufferBinding<'a>,
        pub gravitons: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub app_state: wgpu::BindGroupEntry<'a>,
        pub gravitons: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                app_state: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.app_state),
                },
                gravitons: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.gravitons),
                },
            }
        }
        pub fn as_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.app_state, self.gravitons]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.as_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Shader::BindGroup0::LayoutDescriptor"),
            entries: &[
                /// @binding(0): "app_state"
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(
                            std::mem::size_of::<_root::shader::AppState>() as _,
                        ),
                    },
                    count: None,
                },
                /// @binding(1): "gravitons"
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage {
                            read_only: true,
                        },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(
            device: &wgpu::Device,
            bindings: WgpuBindGroup0Entries,
        ) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(&device);
            let entries = bindings.as_array();
            let bind_group = device
                .create_bind_group(
                    &wgpu::BindGroupDescriptor {
                        label: Some("Shader::BindGroup0"),
                        layout: &bind_group_layout,
                        entries: &entries,
                    },
                );
            Self(bind_group)
        }
        pub fn set<'a>(&self, render_pass: &mut wgpu::RenderPass<'a>) {
            render_pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut wgpu::RenderPass<'a>) {
            self.bind_group0.set(pass);
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::RenderPass<'a>,
        bind_group0: &'a WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: std::collections::HashMap<String, f64>,
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: std::collections::HashMap<String, f64>,
    }
    pub fn fragment_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn fs_main_entry(
        targets: [Option<wgpu::ColorTargetState>; 1],
    ) -> FragmentEntry<1> {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("Shader::PipelineLayout"),
                    bind_group_layouts: &[
                        &WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("shader.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct AppState {
    position: vec2<f32>,
    zoom: f32,
    drag: f32,
    delta_t: f32,
    num_gravitons: u32,
}

struct Graviton {
    position: vec2<f32>,
    color: vec4<f32>,
}

struct VertexInput {
    @builtin(vertex_index) vertex_index: u32,
}

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) coord: vec2<f32>,
}

const MAX_GRAVITONS: u32 = 256u;

@group(0) @binding(0) 
var<uniform> app_state: AppState;
@group(0) @binding(1) 
var<storage> gravitons: array<Graviton>;

@vertex 
fn vs_main(in: VertexInput) -> VertexOutput {
    var vertices: array<vec2<f32>, 3> = array<vec2<f32>, 3>(vec2<f32>(-1f, 1f), vec2<f32>(3f, 1f), vec2<f32>(-1f, -3f));
    var out: VertexOutput;

    let _e14 = vertices[in.vertex_index];
    out.coord = _e14;
    let _e17 = out.coord;
    out.position = vec4<f32>(_e17, 0f, 1f);
    let _e21 = out;
    return _e21;
}

@fragment 
fn fs_main(in_1: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(255f, 0f, 0f, 1f);
}
"#;
}
pub mod layout_asserts {
    use super::{_root, _root::*};
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
}
